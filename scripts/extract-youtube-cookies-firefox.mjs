/* global console, process, setTimeout */
// scripts/extract-youtube-cookies-firefox.mjs
// Firefox-based fallback for YouTube cookie extraction
// Firefox is less commonly fingerprinted by Google than Chromium
// Used as fallback when Chromium + stealth fails
// @see https://playwright.dev/docs/browsers#firefox

import {firefox} from 'playwright'
import {existsSync, mkdirSync, writeFileSync} from 'fs'
import {dirname, join} from 'path'
import {fileURLToPath} from 'url'

const __dirname = dirname(fileURLToPath(import.meta.url))
const PROJECT_ROOT = join(__dirname, '..')
const STATE_DIR = join(PROJECT_ROOT, 'playwright-state-firefox')
const COOKIES_OUTPUT = join(PROJECT_ROOT, 'layers/yt-dlp/cookies/youtube-cookies.txt')
const SCREENSHOTS_DIR = join(PROJECT_ROOT, 'playwright-screenshots')

/** Human-like random delay to avoid detection */
function randomDelay(min = 800, max = 2500) {
  const delay = Math.floor(Math.random() * (max - min) + min)
  return new Promise((resolve) => setTimeout(resolve, delay))
}

/** Convert browser cookies to Netscape cookie format */
function toNetscapeFormat(cookies) {
  const header = [
    '# Netscape HTTP Cookie File',
    '# Generated by Playwright Firefox cookie extraction',
    '# https://github.com/j0nathan-ll0yd/aws-cloudformation-media-downloader',
    ''
  ].join('\n')
  const lines = cookies.map((c) => {
    const domain = c.domain.startsWith('.') ? c.domain : `.${c.domain}`
    const flag = c.domain.startsWith('.') ? 'TRUE' : 'FALSE'
    const path = c.path || '/'
    const secure = c.secure ? 'TRUE' : 'FALSE'
    const expiry = c.expires ? Math.floor(c.expires) : '0'
    return `${domain}\t${flag}\t${path}\t${secure}\t${expiry}\t${c.name}\t${c.value}`
  })
  return header + lines.join('\n') + '\n'
}

/** Save screenshot for debugging */
async function saveScreenshot(page, name) {
  if (!existsSync(SCREENSHOTS_DIR)) {
    mkdirSync(SCREENSHOTS_DIR, {recursive: true})
  }
  const screenshotPath = join(SCREENSHOTS_DIR, `firefox-${name}-${Date.now()}.png`)
  await page.screenshot({path: screenshotPath, fullPage: true})
  console.log(`Screenshot saved: ${screenshotPath}`)
  return screenshotPath
}

/** Check for common Google login challenges */
async function detectLoginChallenge(page) {
  const challenges = [
    {selector: '[data-challengetype]', name: 'verification-challenge'},
    {selector: '#captchaimg', name: 'captcha'},
    {selector: 'iframe[src*="recaptcha"]', name: 'recaptcha'},
    {selector: '[data-sendmethod]', name: 'phone-verification'},
    {selector: '#identifierNext[disabled]', name: 'rate-limited'},
    {selector: 'div[data-error-code]', name: 'error-message'},
    {selector: '#headingText:has-text("Verify")', name: 'verify-prompt'},
    {selector: '#headingText:has-text("Confirm")', name: 'confirm-prompt'},
    {selector: '#headingText:has-text("Choose an account")', name: 'account-chooser'}
  ]
  for (const {selector, name} of challenges) {
    try {
      const visible = await page.locator(selector).first().isVisible({timeout: 1000})
      if (visible) {
        return name
      }
    } catch {
      // Selector not found, continue
    }
  }
  return null
}

/** Handle account chooser screen */
async function handleAccountChooser(page, email) {
  console.log('Account chooser detected, selecting account...')
  await randomDelay(500, 1500)

  // Try to click on the account matching our email
  const accountSelector = `div[data-email="${email}"]`
  const accountExists = await page.locator(accountSelector).isVisible({timeout: 3000}).catch(() => false)
  if (accountExists) {
    await page.click(accountSelector)
    return true
  }
  // Otherwise click "Use another account"
  const useAnother = await page.locator('div:has-text("Use another account")').first().isVisible({timeout: 3000}).catch(() => false)
  if (useAnother) {
    await page.locator('div:has-text("Use another account")').first().click()
    return true
  }
  return false
}

/** Main extraction function using Firefox */
async function extractCookiesFirefox() {
  console.log('Starting YouTube cookie extraction with Firefox (fallback)...')
  if (!existsSync(STATE_DIR)) {
    mkdirSync(STATE_DIR, {recursive: true})
  }

  // Ensure output directory exists
  const cookiesDir = dirname(COOKIES_OUTPUT)
  if (!existsSync(cookiesDir)) {
    mkdirSync(cookiesDir, {recursive: true})
  }

  // Firefox has different anti-detection profile than Chromium
  // and is generally less commonly fingerprinted by Google
  const browser = await firefox.launchPersistentContext(STATE_DIR, {
    headless: true,
    // Firefox-specific settings for stealth
    firefoxUserPrefs: {
      // Disable telemetry
      'toolkit.telemetry.enabled': false,
      'datareporting.policy.dataSubmissionEnabled': false,
      // Disable tracking protection for this use case
      'privacy.trackingprotection.enabled': false,
      // Disable first-run pages
      'browser.shell.checkDefaultBrowser': false,
      'browser.startup.homepage_override.mstone': 'ignore'
    },
    // Realistic viewport
    viewport: {width: 1920, height: 1080},
    // Locale consistency
    locale: 'en-US',
    timezoneId: 'America/Los_Angeles'
  })
  const page = await browser.newPage()

  try {
    // Navigate to YouTube to refresh session
    console.log('Navigating to YouTube with Firefox...')
    await page.goto('https://www.youtube.com', {waitUntil: 'networkidle', timeout: 60000})
    await randomDelay(1000, 2000)

    // Check if logged in by looking for avatar button
    const isLoggedIn = await page.locator('button#avatar-btn').isVisible({timeout: 5000}).catch(() => false)

    if (!isLoggedIn) {
      console.log('Not logged in. Attempting login with Firefox...')
      if (!process.env.YOUTUBE_EMAIL || !process.env.YOUTUBE_PASSWORD) {
        throw new Error('YOUTUBE_EMAIL and YOUTUBE_PASSWORD environment variables required')
      }

      // Click sign in button with human-like delay
      await randomDelay()
      await page.click('a[href*="accounts.google.com"]')
      await page.waitForURL(/accounts\.google\.com/, {timeout: 30000})
      await randomDelay(1500, 3000)
      await saveScreenshot(page, '01-login-page')

      // Check for account chooser first
      const challenge = await detectLoginChallenge(page)
      if (challenge === 'account-chooser') {
        await handleAccountChooser(page, process.env.YOUTUBE_EMAIL)
        await randomDelay(1500, 2500)
      }

      // Enter email if email field is visible
      const emailFieldVisible = await page.locator('input[type="email"]').isVisible({timeout: 5000}).catch(() => false)
      if (emailFieldVisible) {
        console.log('Entering email...')
        await randomDelay(500, 1000)
        await page.locator('input[type="email"]').click()
        await page.locator('input[type="email"]').fill(process.env.YOUTUBE_EMAIL)
        await randomDelay(800, 1500)
        await page.click('#identifierNext')
        await randomDelay(2500, 4000)
      }

      await saveScreenshot(page, '02-after-email')

      // Check for challenges after email entry
      const postEmailChallenge = await detectLoginChallenge(page)
      if (postEmailChallenge) {
        console.error(`Login challenge detected: ${postEmailChallenge}`)
        await saveScreenshot(page, `03-challenge-${postEmailChallenge}`)
        throw new Error(`Google login requires ${postEmailChallenge}. Manual intervention needed.`)
      }

      // Wait for password field
      console.log('Waiting for password field...')
      const passwordSelectors = ['input[type="password"]', 'input[name="Passwd"]', 'input[aria-label="Enter your password"]']

      let passwordFieldFound = false
      for (const selector of passwordSelectors) {
        try {
          await page.waitForSelector(selector, {state: 'visible', timeout: 10000})
          passwordFieldFound = true
          console.log(`Password field found with selector: ${selector}`)

          console.log('Entering password...')
          await randomDelay(500, 1000)
          await page.locator(selector).click()
          await page.locator(selector).fill(process.env.YOUTUBE_PASSWORD)
          await randomDelay(800, 1500)
          break
        } catch {
          console.log(`Password selector not found: ${selector}`)
        }
      }

      if (!passwordFieldFound) {
        await saveScreenshot(page, '03-no-password-field')
        const pageTitle = await page.title()
        const pageUrl = page.url()
        console.error(`Page state - Title: ${pageTitle}, URL: ${pageUrl}`)
        throw new Error('Password field not found. Google may be showing a challenge page.')
      }

      await page.click('#passwordNext')
      await randomDelay(2000, 3500)
      await saveScreenshot(page, '04-after-password')

      // Wait for redirect back to YouTube
      console.log('Waiting for login completion...')
      await page.waitForURL(/youtube\.com/, {timeout: 60000})
      await randomDelay(2500, 4000)
      await saveScreenshot(page, '05-logged-in')
    } else {
      console.log('Already logged in, refreshing session...')
      await page.goto('https://www.youtube.com/feed/subscriptions', {waitUntil: 'networkidle'})
      await randomDelay(1500, 2500)
    }

    // Get all cookies and filter to YouTube/Google domains
    console.log('Extracting cookies from Firefox...')
    const cookies = await browser.cookies()
    const relevantDomains = ['.youtube.com', '.google.com', '.googlevideo.com', 'youtube.com', 'google.com']
    const filteredCookies = cookies.filter((c) => relevantDomains.some((d) => c.domain.endsWith(d) || c.domain === d.slice(1) || c.domain === d))
    console.log(`Found ${filteredCookies.length} relevant cookies`)

    // Convert to Netscape format and write
    const netscapeContent = toNetscapeFormat(filteredCookies)
    writeFileSync(COOKIES_OUTPUT, netscapeContent)
    console.log(`Successfully wrote ${filteredCookies.length} cookies to ${COOKIES_OUTPUT}`)
  } finally {
    await browser.close()
  }
}

extractCookiesFirefox().catch((err) => {
  console.error('Firefox cookie extraction failed:', err)
  process.exit(1)
})
