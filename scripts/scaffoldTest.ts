#!/usr/bin/env tsx
/**
 * Test Scaffolder CLI
 * 
 * Automatically generates test boilerplate with proper mocking setup.
 * Uses AST analysis to detect imports and generate appropriate mocks.
 * 
 * Usage:
 *   pnpm scaffold:test <file-path>
 * 
 * Example:
 *   pnpm scaffold:test src/lambdas/StartFileUpload/src/index.ts
 */

import {existsSync, writeFileSync} from 'fs'
import {dirname, join, relative, basename} from 'path'
import {Project} from 'ts-morph'

interface ImportInfo {
  modulePath: string
  isAwsSdk: boolean
  isElectroDB: boolean
  isVendorWrapper: boolean
  namedImports: string[]
}

/**
 * Analyze a source file to extract import information
 */
function analyzeSourceFile(filePath: string): ImportInfo[] {
  const project = new Project({tsConfigFilePath: join(process.cwd(), 'tsconfig.json')})
  const sourceFile = project.addSourceFileAtPath(filePath)
  const imports: ImportInfo[] = []

  for (const importDecl of sourceFile.getImportDeclarations()) {
    const moduleSpecifier = importDecl.getModuleSpecifierValue()
    
    const namedImports = importDecl.getNamedImports().map(ni => ni.getName())
    
    imports.push({
      modulePath: moduleSpecifier,
      isAwsSdk: moduleSpecifier.startsWith('@aws-sdk/'),
      isElectroDB: moduleSpecifier.includes('entities') || moduleSpecifier.includes('ElectroDB'),
      isVendorWrapper: moduleSpecifier.includes('#lib/vendor/'),
      namedImports
    })
  }

  return imports
}

/**
 * Generate mock setup code for an import
 */
function generateMockSetup(imp: ImportInfo): string {
  if (imp.isElectroDB) {
    return `// Mock ElectroDB entity
jest.unstable_mockModule('${imp.modulePath}', () =>
  createElectroDBEntityMock({
    get: jest.fn().mockResolvedValue({data: null}),
    query: jest.fn().mockResolvedValue({data: []}),
    put: jest.fn().mockResolvedValue({data: {}}),
    update: jest.fn().mockResolvedValue({data: {}}),
    delete: jest.fn().mockResolvedValue({data: {}})
  })
)`
  }
  
  if (imp.isVendorWrapper) {
    const mockExports = imp.namedImports.map(name => 
      `  ${name}: jest.fn<() => Promise<unknown>>().mockResolvedValue({})`
    ).join(',\n')
    
    return `// Mock vendor wrapper
jest.unstable_mockModule('${imp.modulePath}', () => ({
${mockExports}
}))`
  }
  
  if (imp.isAwsSdk) {
    return `// WARNING: Direct AWS SDK import detected
// This should use vendor wrappers instead
jest.unstable_mockModule('${imp.modulePath}', () => ({
  // Add mocks here
}))`
  }
  
  // Generic module mock
  const mockExports = imp.namedImports.map(name => 
    `  ${name}: jest.fn()`
  ).join(',\n')
  
  return `jest.unstable_mockModule('${imp.modulePath}', () => ({
${mockExports}
}))`
}

/**
 * Generate complete test file content
 */
function generateTestFile(sourceFilePath: string, imports: ImportInfo[]): string {
  const fileName = basename(sourceFilePath, '.ts')
  const relativePath = relative(process.cwd(), sourceFilePath)
  
  const mockSetups = imports
    .filter(imp => !imp.modulePath.startsWith('#types/'))
    .map(imp => generateMockSetup(imp))
    .join('\n\n')
  
  const hasElectroDB = imports.some(imp => imp.isElectroDB)
  const helperImports = hasElectroDB 
    ? "import {createElectroDBEntityMock} from '#test/helpers/electrodb-mock'\n" 
    : ""

  return `/**
 * Tests for ${relativePath}
 * 
 * AUTO-GENERATED by scaffold:test
 * TODO: Fill in test cases
 */

import {describe, it, expect, jest, beforeEach} from '@jest/globals'
${helperImports}
// ============================================================================
// MOCKS - Must be set up BEFORE importing the module under test
// ============================================================================

${mockSetups}

// ============================================================================
// IMPORTS - Import after all mocks are configured
// ============================================================================

const {handler} = await import('../src/index')

// ============================================================================
// TEST SETUP
// ============================================================================

describe('${fileName}', () => {
  beforeEach(() => {
    jest.clearAllMocks()
  })

  describe('handler', () => {
    it('should exist', () => {
      expect(handler).toBeDefined()
      expect(typeof handler).toBe('function')
    })

    // TODO: Add test cases
    it.todo('should handle valid input')
    it.todo('should handle invalid input')
    it.todo('should handle errors')
  })
})
`
}

/**
 * Main execution
 */
function main(): void {
  const args = process.argv.slice(2)
  
  if (args.length === 0) {
    console.error('Usage: pnpm scaffold:test <file-path>')
    console.error('Example: pnpm scaffold:test src/lambdas/StartFileUpload/src/index.ts')
    process.exit(1)
  }

  const sourceFilePath = args[0]
  
  if (!existsSync(sourceFilePath)) {
    console.error(`‚ùå File not found: ${sourceFilePath}`)
    process.exit(1)
  }

  console.log(`üîç Analyzing ${sourceFilePath}...`)
  
  const imports = analyzeSourceFile(sourceFilePath)
  console.log(`üì¶ Found ${imports.length} imports`)
  
  const testContent = generateTestFile(sourceFilePath, imports)
  
  // Determine output path
  const sourceDir = dirname(sourceFilePath)
  const testDir = join(dirname(sourceDir), 'test')
  const testFileName = basename(sourceFilePath, '.ts') + '.test.ts'
  const testFilePath = join(testDir, testFileName)
  
  if (existsSync(testFilePath)) {
    console.error(`‚ùå Test file already exists: ${testFilePath}`)
    console.error('Remove the existing file or use a different name.')
    process.exit(1)
  }

  writeFileSync(testFilePath, testContent, 'utf-8')
  console.log(`‚úÖ Test file generated: ${testFilePath}`)
  console.log('')
  console.log('Next steps:')
  console.log('1. Review the generated mocks and adjust as needed')
  console.log('2. Fill in the TODO test cases')
  console.log('3. Run tests with: pnpm test')
}

main()
