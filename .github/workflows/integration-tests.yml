name: Integration Tests

on:
  push:
    branches: ['**']
  pull_request:
    branches: [master]
  workflow_call:

jobs:
  integration-tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - uses: ./.github/actions/setup-node-pnpm

      # Note: Type checking and linting removed - unit-tests workflow handles these

      - name: Start LocalStack and PostgreSQL
        run: |
          docker compose -f docker-compose.localstack.yml up -d
          docker compose -f docker-compose.test.yml up -d
          echo "Waiting for services to be ready..."

      - name: Wait for LocalStack health check
        run: |
          max_retries=30
          retry_count=0

          while [ $retry_count -lt $max_retries ]; do
            if curl -sf http://localhost:4566/_localstack/health > /dev/null 2>&1; then
              echo "LocalStack is healthy"
              curl -s http://localhost:4566/_localstack/health | jq
              break
            fi

            retry_count=$((retry_count + 1))
            echo "Attempt $retry_count of $max_retries..."
            sleep 1
          done

          if [ $retry_count -eq $max_retries ]; then
            echo "LocalStack failed to become healthy"
            docker compose -f docker-compose.localstack.yml logs
            exit 1
          fi

      - name: Wait for PostgreSQL health check
        run: |
          max_retries=30
          retry_count=0

          while [ $retry_count -lt $max_retries ]; do
            if docker compose -f docker-compose.test.yml exec -T postgres pg_isready -U test -d media_downloader_test > /dev/null 2>&1; then
              echo "PostgreSQL is healthy"
              exit 0
            fi

            retry_count=$((retry_count + 1))
            echo "Attempt $retry_count of $max_retries..."
            sleep 1
          done

          echo "PostgreSQL failed to become healthy"
          docker compose -f docker-compose.test.yml logs
          exit 1

      - name: Verify all LocalStack services
        env:
          AWS_ACCESS_KEY_ID: test
          AWS_SECRET_ACCESS_KEY: test
          AWS_DEFAULT_REGION: us-west-2
        run: |
          echo "Verifying all required LocalStack services..."
          ENDPOINT="http://localhost:4566"

          # Verify SQS
          echo "Checking SQS..."
          QUEUE_URL=$(aws --endpoint-url=$ENDPOINT sqs create-queue --queue-name ci-readiness-check --output text --query 'QueueUrl') || {
            echo "SQS create-queue failed"
            exit 1
          }
          aws --endpoint-url=$ENDPOINT sqs delete-queue --queue-url "$QUEUE_URL" || true
          echo "✓ SQS operational"

          # Verify EventBridge
          echo "Checking EventBridge..."
          aws --endpoint-url=$ENDPOINT events list-event-buses > /dev/null || {
            echo "EventBridge list-event-buses failed"
            exit 1
          }
          echo "✓ EventBridge operational"

          # Verify S3
          echo "Checking S3..."
          aws --endpoint-url=$ENDPOINT s3 mb s3://ci-readiness-check 2>/dev/null || true
          aws --endpoint-url=$ENDPOINT s3 rb s3://ci-readiness-check 2>/dev/null || true
          echo "✓ S3 operational"

          # Verify SNS platform application
          echo "Checking SNS..."
          CREATE_RESULT=$(aws --endpoint-url=$ENDPOINT sns create-platform-application \
            --name ci-readiness-check \
            --platform APNS \
            --attributes PlatformCredential=test,PlatformPrincipal=test \
            --output json 2>&1) || {
            echo "Failed to create test platform app: $CREATE_RESULT"
            exit 1
          }

          APP_ARN=$(echo "$CREATE_RESULT" | jq -r '.PlatformApplicationArn')
          ENDPOINT_RESULT=$(aws --endpoint-url=$ENDPOINT sns create-platform-endpoint \
            --platform-application-arn "$APP_ARN" \
            --token "test-device-token-readiness" \
            --output json 2>&1) || {
            echo "Failed to create test endpoint: $ENDPOINT_RESULT"
            exit 1
          }

          ENDPOINT_ARN=$(echo "$ENDPOINT_RESULT" | jq -r '.EndpointArn')
          aws --endpoint-url=$ENDPOINT sns delete-endpoint --endpoint-arn "$ENDPOINT_ARN" || true
          aws --endpoint-url=$ENDPOINT sns delete-platform-application --platform-application-arn "$APP_ARN" || true
          echo "✓ SNS operational"

          echo ""
          echo "All LocalStack services verified successfully"

      - name: Create test results directory
        run: mkdir -p test-results

      - name: Run integration tests (with CI-level retry)
        id: integration-tests
        run: |
          # Capture start time
          START_TIME=$(date +%s)

          # Run tests with automatic retry on failure
          # First attempt
          if pnpm run test:integration --coverage; then
            echo "Tests passed on first attempt"
            echo "attempt=1" >> "$GITHUB_OUTPUT"
          else
            echo "First attempt failed, retrying..."
            echo ""
            # Second attempt - clear any stale state first
            sleep 5
            if pnpm run test:integration --coverage; then
              echo "Tests passed on retry"
              echo "attempt=2" >> "$GITHUB_OUTPUT"
              echo "⚠️ Tests required CI-level retry to pass" >> "$GITHUB_STEP_SUMMARY"
            else
              echo "Tests failed after retry"
              echo "attempt=failed" >> "$GITHUB_OUTPUT"
              # Capture duration even on failure
              END_TIME=$(date +%s)
              DURATION=$((END_TIME - START_TIME))
              echo "duration=${DURATION}" >> "$GITHUB_OUTPUT"
              exit 1
            fi
          fi

          # Capture duration on success
          END_TIME=$(date +%s)
          DURATION=$((END_TIME - START_TIME))
          echo "duration=${DURATION}" >> "$GITHUB_OUTPUT"
        env:
          CI: true
          USE_LOCALSTACK: true
          TEST_DATABASE_URL: postgres://test:test@localhost:5432/media_downloader_test

      - name: Parse flaky tests from JUnit report
        if: always() && hashFiles('test-results/integration-results.xml') != ''
        run: |
          # Extract retried tests from JUnit XML (tests with retries have multiple testcase entries)
          # JUnit format: <testcase name="..." classname="..." time="...">
          # Retried tests will show in the report with "retry #N" in their output

          echo "## Integration Test Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"

          # Count total tests, failures, and errors from JUnit
          if command -v xmllint &> /dev/null; then
            TESTS=$(xmllint --xpath "string(//testsuite/@tests)" test-results/integration-results.xml 2>/dev/null || echo "0")
            FAILURES=$(xmllint --xpath "string(//testsuite/@failures)" test-results/integration-results.xml 2>/dev/null || echo "0")
            ERRORS=$(xmllint --xpath "string(//testsuite/@errors)" test-results/integration-results.xml 2>/dev/null || echo "0")
            TIME=$(xmllint --xpath "string(//testsuite/@time)" test-results/integration-results.xml 2>/dev/null || echo "0")

            echo "| Metric | Value |" >> "$GITHUB_STEP_SUMMARY"
            echo "|--------|-------|" >> "$GITHUB_STEP_SUMMARY"
            echo "| Total Tests | $TESTS |" >> "$GITHUB_STEP_SUMMARY"
            echo "| Failures | $FAILURES |" >> "$GITHUB_STEP_SUMMARY"
            echo "| Errors | $ERRORS |" >> "$GITHUB_STEP_SUMMARY"
            echo "| Test Duration | ${TIME}s |" >> "$GITHUB_STEP_SUMMARY"
            echo "| Total Run Duration | ${{ steps.integration-tests.outputs.duration }}s |" >> "$GITHUB_STEP_SUMMARY"
            echo "| CI Attempt | ${{ steps.integration-tests.outputs.attempt }} |" >> "$GITHUB_STEP_SUMMARY"
          else
            echo "JUnit report generated at test-results/integration-results.xml" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "| Metric | Value |" >> "$GITHUB_STEP_SUMMARY"
            echo "|--------|-------|" >> "$GITHUB_STEP_SUMMARY"
            echo "| Total Run Duration | ${{ steps.integration-tests.outputs.duration }}s |" >> "$GITHUB_STEP_SUMMARY"
            echo "| CI Attempt | ${{ steps.integration-tests.outputs.attempt }} |" >> "$GITHUB_STEP_SUMMARY"
          fi

          # Check for flaky test warnings in the test output
          if grep -q "\[FLAKY\]" test-results/integration-results.xml 2>/dev/null; then
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "### Flaky Tests Detected" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            echo "The following tests required retries to pass:" >> "$GITHUB_STEP_SUMMARY"
            echo "" >> "$GITHUB_STEP_SUMMARY"
            grep -o '\[FLAKY\][^<]*' test-results/integration-results.xml | head -20 >> "$GITHUB_STEP_SUMMARY" || true
          fi

          # Write metrics JSON for artifact
          cat > test-results/metrics.json << EOF
          {
            "totalTests": $TESTS,
            "failures": $FAILURES,
            "errors": $ERRORS,
            "testDuration": "$TIME",
            "runDuration": "${{ steps.integration-tests.outputs.duration }}",
            "ciAttempt": "${{ steps.integration-tests.outputs.attempt }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

      - name: Post coverage to job summary
        if: always() && hashFiles('coverage/integration/coverage-summary.md') != ''
        run: |
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "## Integration Test Coverage" >> "$GITHUB_STEP_SUMMARY"
          cat coverage/integration/coverage-summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v6
        with:
          name: integration-test-results
          path: |
            coverage/
            test-results/
          retention-days: 7

      - name: Capture diagnostics on failure
        if: failure()
        env:
          AWS_ACCESS_KEY_ID: test
          AWS_SECRET_ACCESS_KEY: test
          AWS_DEFAULT_REGION: us-west-2
        run: |
          ENDPOINT="http://localhost:4566"

          echo "=== PostgreSQL Active Connections ==="
          docker compose -f docker-compose.test.yml exec -T postgres psql -U test -d media_downloader_test -c "SELECT pid, usename, state, query_start, left(query, 80) as query FROM pg_stat_activity WHERE datname = 'media_downloader_test'" 2>/dev/null || echo "Could not query pg_stat_activity"
          echo ""

          echo "=== PostgreSQL Schemas ==="
          docker compose -f docker-compose.test.yml exec -T postgres psql -U test -d media_downloader_test -c "\dn" 2>/dev/null || echo "Could not list schemas"
          echo ""

          echo "=== SQS Queues ==="
          aws --endpoint-url=$ENDPOINT sqs list-queues 2>/dev/null || echo "Could not list SQS queues"
          echo ""

          echo "=== EventBridge Event Buses ==="
          aws --endpoint-url=$ENDPOINT events list-event-buses 2>/dev/null || echo "Could not list EventBridge buses"
          echo ""

          echo "=== EventBridge Rules ==="
          aws --endpoint-url=$ENDPOINT events list-rules 2>/dev/null || echo "Could not list EventBridge rules"
          echo ""

          echo "=== LocalStack Service Status ==="
          curl -s http://localhost:4566/_localstack/health | jq 2>/dev/null || echo "Could not fetch LocalStack health"
          echo ""

          echo "=== LocalStack Logs (last 150 lines) ==="
          docker compose -f docker-compose.localstack.yml logs --tail=150
          echo ""

          echo "=== PostgreSQL Logs (last 50 lines) ==="
          docker compose -f docker-compose.test.yml logs --tail=50

      - name: Stop services
        if: always()
        run: |
          docker compose -f docker-compose.localstack.yml down
          docker compose -f docker-compose.test.yml down
