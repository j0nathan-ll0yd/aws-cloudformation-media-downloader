/**
 * Better Auth Entities Integration Tests
 *
 * Tests Better Auth ElectroDB entities (Users, Sessions, Accounts, VerificationTokens)
 * against LocalStack DynamoDB to validate:
 * - Entity CRUD operations
 * - GSI queries (byEmail, byUser, byDevice, byProvider)
 * - Collections queries (userSessions, userAccounts)
 * - Complete authentication flows
 */

// CRITICAL: Set environment variables BEFORE any imports that use them
// ES modules evaluate imports before file code runs, but we can set env vars
// before the dynamic imports below are resolved
const TEST_TABLE = 'MediaDownloader'
process.env.DynamoDBTableName = TEST_TABLE
process.env.USE_LOCALSTACK = 'true'
process.env.AWS_REGION = 'us-east-1'

import {describe, it, expect, beforeAll, afterAll, afterEach} from '@jest/globals'
import {setupLocalStackTable, cleanupLocalStackTable} from '../helpers/electrodb-localstack'

// Dynamic imports to ensure env vars are set before entity instantiation
const {Users} = await import('../../../src/entities/Users')
const {Sessions} = await import('../../../src/entities/Sessions')
const {Accounts} = await import('../../../src/entities/Accounts')
const {VerificationTokens} = await import('../../../src/entities/VerificationTokens')
const {MediaDownloaderService} = await import('../../../src/entities/Collections')
const {createMockUser, createMockSession, createMockAccount, createMockVerificationToken, createMinimalUser} = await import('../../helpers/better-auth-test-data')
const {transformUserFromAuth, transformSessionFromAuth, transformAccountFromAuth, transformUserToAuth, transformSessionToAuth, transformAccountToAuth, splitFullName} = await import('../../../src/lib/vendor/BetterAuth/electrodb-adapter')

// Type helpers for ElectroDB service collections
// ElectroDB collections return an object with entity-named arrays, not a flat array
interface UserSessionsData {
  Users: Array<{userId: string; [key: string]: unknown}>
  Sessions: Array<{sessionId: string; [key: string]: unknown}>
}

interface UserAccountsData {
  Users: Array<{userId: string; [key: string]: unknown}>
  Accounts: Array<{accountId: string; providerId: string; [key: string]: unknown}>
}

type ServiceCollections = {
  userSessions: (params: {userId: string}) => {go: () => Promise<{data: UserSessionsData}>}
  userAccounts: (params: {userId: string}) => {go: () => Promise<{data: UserAccountsData}>}
}

const collections = MediaDownloaderService.collections as unknown as ServiceCollections

describe('Better Auth Entities Integration Tests', () => {
  beforeAll(async () => {
    await setupLocalStackTable()
  })

  afterAll(async () => {
    await cleanupLocalStackTable()
  })

  afterEach(async () => {
    // Clean up test data after each test
    // Note: In production, you'd want more sophisticated cleanup
  })

  describe('Users Entity', () => {
    it('should create and retrieve user by userId', async () => {
      const userData = createMockUser({
        userId: 'user-test-1',
        emailVerified: true,
        identityProviders: {
          userId: 'apple-123',
          email: 'test@example.com',
          emailVerified: true,
          isPrivateEmail: false,
          accessToken: 'mock-access-token',
          refreshToken: 'mock-refresh-token',
          tokenType: 'Bearer',
          expiresAt: Date.now() + 3600000
        }
      })

      await Users.create(userData).go()

      const result = await Users.get({userId: 'user-test-1'}).go()

      expect(result.data).toBeDefined()
      expect(result.data?.userId).toBe('user-test-1')
      expect(result.data?.email).toBe('test@example.com')
      expect(result.data?.firstName).toBe('John')
      expect(result.data?.lastName).toBe('Doe')
      // Note: createdAt/updatedAt are auto-generated by DynamoDB and verified in other tests
    })

    it('should query user by email using byEmail GSI', async () => {
      const userData = createMockUser({
        userId: 'user-test-2',
        email: 'unique@example.com',
        firstName: 'Jane',
        lastName: 'Smith'
      })

      await Users.create(userData).go()

      const result = await Users.query.byEmail({email: 'unique@example.com'}).go()

      expect(result.data).toHaveLength(1)
      expect(result.data[0].userId).toBe('user-test-2')
      expect(result.data[0].email).toBe('unique@example.com')
    })

    it('should return empty array for non-existent email', async () => {
      const result = await Users.query.byEmail({email: 'nonexistent@example.com'}).go()

      expect(result.data).toHaveLength(0)
    })

    it('should update user fields', async () => {
      const userData = createMinimalUser({
        userId: 'user-test-3',
        email: 'update@example.com',
        firstName: 'Old',
        lastName: 'Name'
      })

      await Users.create(userData).go()

      await Users.update({userId: 'user-test-3'})
        .set({
          firstName: 'New',
          lastName: 'Updated',
          emailVerified: true
        })
        .go()

      const result = await Users.get({userId: 'user-test-3'}).go()

      expect(result.data?.firstName).toBe('New')
      expect(result.data?.lastName).toBe('Updated')
      expect(result.data?.emailVerified).toBe(true)
    })
  })

  describe('Sessions Entity', () => {
    it('should create and retrieve session', async () => {
      const sessionData = createMockSession({
        sessionId: 'session-test-1',
        userId: 'user-session-1',
        token: 'hashed-token-123',
        ipAddress: '192.168.1.1',
        userAgent: 'Mozilla/5.0...',
        expiresAt: Date.now() + 86400000
      })

      await Sessions.create(sessionData).go()

      const result = await Sessions.get({sessionId: 'session-test-1'}).go()

      expect(result.data).toBeDefined()
      expect(result.data?.sessionId).toBe('session-test-1')
      expect(result.data?.userId).toBe('user-session-1')
      expect(result.data?.token).toBe('hashed-token-123')
      expect(result.data?.deviceId).toBe('device-123')
      expect(result.data?.createdAt).toBeDefined()
      expect(result.data?.updatedAt).toBeDefined()
    })

    it('should query sessions by user using byUser GSI', async () => {
      const userId = 'user-multi-session'

      await Sessions.create(
        createMockSession({
          sessionId: 'session-1',
          userId,
          token: 'token-1',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      await Sessions.create(
        createMockSession({
          sessionId: 'session-2',
          userId,
          token: 'token-2',
          expiresAt: Date.now() + 172800000
        })
      ).go()

      await Sessions.create(
        createMockSession({
          sessionId: 'session-3',
          userId,
          token: 'token-3',
          expiresAt: Date.now() + 259200000
        })
      ).go()

      const result = await Sessions.query.byUser({userId}).go()

      expect(result.data).toHaveLength(3)
      expect(result.data.every((s) => s.userId === userId)).toBe(true)
      // Verify sorted by expiresAt (composite sort key)
      for (let i = 0; i < result.data.length - 1; i++) {
        expect(result.data[i].expiresAt).toBeLessThanOrEqual(result.data[i + 1].expiresAt)
      }
    })

    it('should query sessions by device using byDevice GSI', async () => {
      const deviceId = 'device-multi-session'

      await Sessions.create(
        createMockSession({
          sessionId: 'device-session-1',
          userId: 'user-1',
          deviceId,
          token: 'token-1',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      await Sessions.create(
        createMockSession({
          sessionId: 'device-session-2',
          userId: 'user-2',
          deviceId,
          token: 'token-2',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      const result = await Sessions.query.byDevice({deviceId}).go()

      expect(result.data).toHaveLength(2)
      expect(result.data.every((s) => s.deviceId === deviceId)).toBe(true)
    })

    it('should update session expiration', async () => {
      await Sessions.create(
        createMockSession({
          sessionId: 'session-update-1',
          userId: 'user-1',
          token: 'token-1',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      const newExpiresAt = Date.now() + 172800000

      await Sessions.update({sessionId: 'session-update-1'})
        .set({
          expiresAt: newExpiresAt
        })
        .go()

      const result = await Sessions.get({sessionId: 'session-update-1'}).go()

      expect(result.data?.expiresAt).toBe(newExpiresAt)
    })

    it('should delete session', async () => {
      await Sessions.create(
        createMockSession({
          sessionId: 'session-delete-1',
          userId: 'user-1',
          token: 'token-1',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      await Sessions.delete({sessionId: 'session-delete-1'}).go()

      const result = await Sessions.get({sessionId: 'session-delete-1'}).go()

      expect(result.data).toBeNull()
    })
  })

  describe('Accounts Entity', () => {
    it('should create and retrieve OAuth account', async () => {
      const accountData = createMockAccount({
        accountId: 'account-test-1',
        userId: 'user-oauth-1',
        providerAccountId: 'apple-user-123',
        accessToken: 'access-token-123',
        refreshToken: 'refresh-token-123',
        expiresAt: Date.now() + 3600000,
        scope: 'email name',
        idToken: 'id-token-123'
      })

      await Accounts.create(accountData).go()

      const result = await Accounts.get({accountId: 'account-test-1'}).go()

      expect(result.data).toBeDefined()
      expect(result.data?.accountId).toBe('account-test-1')
      expect(result.data?.providerId).toBe('apple')
      expect(result.data?.providerAccountId).toBe('apple-user-123')
      expect(result.data?.accessToken).toBe('access-token-123')
      expect(result.data?.createdAt).toBeDefined()
      expect(result.data?.updatedAt).toBeDefined()
    })

    it('should query accounts by user using byUser GSI', async () => {
      const userId = 'user-multi-provider'

      await Accounts.create(
        createMockAccount({
          accountId: 'account-apple',
          userId,
          providerId: 'apple',
          providerAccountId: 'apple-123'
        })
      ).go()

      await Accounts.create(
        createMockAccount({
          accountId: 'account-google',
          userId,
          providerId: 'google',
          providerAccountId: 'google-123'
        })
      ).go()

      const result = await Accounts.query.byUser({userId}).go()

      expect(result.data).toHaveLength(2)
      expect(result.data.map((a) => a.providerId).sort()).toEqual(['apple', 'google'])
    })

    it('should query account by provider using byProvider GSI', async () => {
      await Accounts.create(
        createMockAccount({
          accountId: 'account-lookup-1',
          userId: 'user-lookup-1',
          providerAccountId: 'apple-unique-id'
        })
      ).go()

      const result = await Accounts.query
        .byProvider({
          providerId: 'apple',
          providerAccountId: 'apple-unique-id'
        })
        .go()

      expect(result.data).toHaveLength(1)
      expect(result.data[0].userId).toBe('user-lookup-1')
      expect(result.data[0].accountId).toBe('account-lookup-1')
    })
  })

  describe('VerificationTokens Entity', () => {
    it('should create and retrieve verification token', async () => {
      const tokenData = createMockVerificationToken({
        token: 'verify-token-123'
      })

      await VerificationTokens.create(tokenData).go()

      const result = await VerificationTokens.get({token: 'verify-token-123'}).go()

      expect(result.data).toBeDefined()
      expect(result.data?.token).toBe('verify-token-123')
      expect(result.data?.identifier).toBe('test@example.com')
      expect(result.data?.expiresAt).toBeGreaterThan(Date.now())
    })

    it('should delete verification token after use', async () => {
      await VerificationTokens.create(
        createMockVerificationToken({
          token: 'temp-token-123',
          identifier: 'user@example.com'
        })
      ).go()

      await VerificationTokens.delete({token: 'temp-token-123'}).go()

      const result = await VerificationTokens.get({token: 'temp-token-123'}).go()

      expect(result.data).toBeNull()
    })
  })

  // Note: userSessions and userAccounts collections are documented but not yet implemented
  // in ElectroDB. These tests are skipped until collection support is added to entities.
  describe.skip('Collections - Better Auth Queries', () => {
    it('should query userSessions collection', async () => {
      const userId = 'user-collection-1'

      // Create user
      await Users.create(
        createMockUser({
          userId,
          email: 'collection@example.com',
          emailVerified: true,
          firstName: 'Collection',
          lastName: 'Test'
        })
      ).go()

      // Create sessions
      await Sessions.create(
        createMockSession({
          sessionId: 'coll-session-1',
          userId,
          token: 'token-1',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      await Sessions.create(
        createMockSession({
          sessionId: 'coll-session-2',
          userId,
          token: 'token-2',
          expiresAt: Date.now() + 86400000
        })
      ).go()

      // Query collection
      const result = await collections.userSessions({userId}).go()

      expect(result.data.Users).toHaveLength(1)
      expect(result.data.Sessions).toHaveLength(2)
      expect(result.data.Users[0].userId).toBe(userId)
    })

    it('should query userAccounts collection', async () => {
      const userId = 'user-collection-2'

      // Create user
      await Users.create(
        createMockUser({
          userId,
          email: 'accounts@example.com',
          emailVerified: true,
          firstName: 'Accounts',
          lastName: 'Test'
        })
      ).go()

      // Create OAuth accounts
      await Accounts.create(
        createMockAccount({
          accountId: 'coll-acc-apple',
          userId,
          providerId: 'apple',
          providerAccountId: 'apple-coll-123'
        })
      ).go()

      await Accounts.create(
        createMockAccount({
          accountId: 'coll-acc-google',
          userId,
          providerId: 'google',
          providerAccountId: 'google-coll-123'
        })
      ).go()

      // Query collection
      const result = await collections.userAccounts({userId}).go()

      expect(result.data.Users).toHaveLength(1)
      expect(result.data.Accounts).toHaveLength(2)
      expect(result.data.Accounts.map((a: {providerId: string}) => a.providerId).sort()).toEqual(['apple', 'google'])
    })
  })

  describe('Complete Authentication Flow', () => {
    it('should handle complete user registration and login flow', async () => {
      const userId = 'user-complete-flow'
      const email = 'complete@example.com'

      // Step 1: Register user
      await Users.create(
        createMockUser({
          userId,
          email,
          firstName: 'Complete',
          lastName: 'Flow'
        })
      ).go()

      // Step 2: Link OAuth account (Apple)
      await Accounts.create(
        createMockAccount({
          accountId: 'flow-account-1',
          userId,
          providerAccountId: 'apple-flow-123',
          accessToken: 'flow-access-token',
          refreshToken: 'flow-refresh-token',
          expiresAt: Date.now() + 3600000
        })
      ).go()

      // Step 3: Create session
      await Sessions.create(
        createMockSession({
          sessionId: 'flow-session-1',
          userId,
          token: 'flow-session-token',
          expiresAt: Date.now() + 86400000,
          ipAddress: '192.168.1.100',
          userAgent: 'iOS App/1.0'
        })
      ).go()

      // Verify: User can be found by email
      const userByEmail = await Users.query.byEmail({email}).go()
      expect(userByEmail.data).toHaveLength(1)
      expect(userByEmail.data[0].userId).toBe(userId)

      // Verify: Account can be found by provider
      const accountByProvider = await Accounts.query
        .byProvider({
          providerId: 'apple',
          providerAccountId: 'apple-flow-123'
        })
        .go()
      expect(accountByProvider.data).toHaveLength(1)
      expect(accountByProvider.data[0].userId).toBe(userId)

      // Verify: Sessions can be queried
      const userSessions = await Sessions.query.byUser({userId}).go()
      expect(userSessions.data).toHaveLength(1)
      expect(userSessions.data[0].token).toBe('flow-session-token')

      // Verify: Accounts can be queried by user
      const userAccounts = await Accounts.query.byUser({userId}).go()
      expect(userAccounts.data).toHaveLength(1)
      expect(userAccounts.data[0].providerId).toBe('apple')
    })
  })

  describe('Edge Cases', () => {
    it('should handle session expiration filtering', async () => {
      const userId = 'user-expiration-test'
      const now = Date.now()

      // Create expired session
      await Sessions.create(
        createMockSession({
          sessionId: 'expired-session',
          userId,
          token: 'expired-token',
          expiresAt: now - 1000
        })
      ).go()

      // Create active session
      await Sessions.create(
        createMockSession({
          sessionId: 'active-session',
          userId,
          token: 'active-token',
          expiresAt: now + 86400000
        })
      ).go()

      // Query all sessions
      const allSessions = await Sessions.query.byUser({userId}).go()

      // Filter to active only (application-level filtering)
      const activeSessions = allSessions.data.filter((s) => s.expiresAt > now)

      expect(allSessions.data).toHaveLength(2)
      expect(activeSessions).toHaveLength(1)
      expect(activeSessions[0].sessionId).toBe('active-session')
    })

    it('should handle duplicate account creation gracefully', async () => {
      await Accounts.create(
        createMockAccount({
          accountId: 'dup-account-1',
          userId: 'user-dup-1',
          providerAccountId: 'apple-dup-123'
        })
      ).go()

      // Attempting to create account with same accountId should fail
      await expect(
        Accounts.create(
          createMockAccount({
            accountId: 'dup-account-1',
            userId: 'user-dup-2',
            providerId: 'google',
            providerAccountId: 'google-456'
          })
        ).go()
      ).rejects.toThrow()
    })
  })

  describe('Transformer Validation (Better Auth â†” ElectroDB)', () => {
    it('should correctly transform and round-trip User data', async () => {
      // Better Auth format
      const betterAuthUser = {
        id: 'user-transform-1',
        email: 'transform@example.com',
        name: 'Transform Test',
        emailVerified: true
      }

      // Transform to ElectroDB format
      const electroUser = transformUserFromAuth(betterAuthUser)

      // Verify transformation splits name correctly
      expect(electroUser.firstName).toBe('Transform')
      expect(electroUser.lastName).toBe('Test')

      // Store in DynamoDB
      await Users.create(electroUser).go()

      // Retrieve from DynamoDB
      const result = await Users.get({userId: 'user-transform-1'}).go()

      // Transform back to Better Auth format
      const roundTripped = transformUserToAuth(result.data!)

      // Verify round-trip preserves data
      expect(roundTripped.id).toBe(betterAuthUser.id)
      expect(roundTripped.email).toBe(betterAuthUser.email)
      expect(roundTripped.name).toBe(betterAuthUser.name)
      expect(roundTripped.emailVerified).toBe(betterAuthUser.emailVerified)
      expect(roundTripped.createdAt).toBeInstanceOf(Date)
      expect(roundTripped.updatedAt).toBeInstanceOf(Date)
    })

    it('should correctly transform and round-trip Session data', async () => {
      const expiresAt = new Date(Date.now() + 86400000)

      // Better Auth format
      const betterAuthSession = {
        id: 'session-transform-1',
        userId: 'user-session-transform',
        expiresAt,
        token: 'transform-token',
        ipAddress: '10.0.0.1',
        userAgent: 'Test Agent'
      }

      // Transform to ElectroDB format
      const electroSession = transformSessionFromAuth(betterAuthSession)

      // Verify transformation converts Date to timestamp
      expect(typeof electroSession.expiresAt).toBe('number')
      expect(electroSession.expiresAt).toBe(expiresAt.getTime())

      // Store in DynamoDB
      await Sessions.create(electroSession).go()

      // Retrieve from DynamoDB
      const result = await Sessions.get({sessionId: 'session-transform-1'}).go()

      // Transform back to Better Auth format
      const roundTripped = transformSessionToAuth(result.data!)

      // Verify round-trip preserves data
      expect(roundTripped.id).toBe(betterAuthSession.id)
      expect(roundTripped.userId).toBe(betterAuthSession.userId)
      expect(roundTripped.expiresAt).toBeInstanceOf(Date)
      expect(roundTripped.expiresAt.getTime()).toBe(expiresAt.getTime())
      expect(roundTripped.token).toBe(betterAuthSession.token)
      expect(roundTripped.ipAddress).toBe(betterAuthSession.ipAddress)
      expect(roundTripped.userAgent).toBe(betterAuthSession.userAgent)
    })

    it('should correctly transform and round-trip Account data', async () => {
      // Better Auth format (note: 'accountId' field is provider's ID)
      const betterAuthAccount = {
        id: 'account-transform-1',
        userId: 'user-account-transform',
        providerId: 'apple',
        accountId: 'apple-transform-123', // This is providerAccountId in ElectroDB
        accessToken: 'access-token',
        refreshToken: 'refresh-token',
        expiresAt: Date.now() + 3600000,
        scope: 'email profile',
        tokenType: 'Bearer'
      }

      // Transform to ElectroDB format
      const electroAccount = transformAccountFromAuth(betterAuthAccount)

      // Verify field name mapping
      expect(electroAccount.accountId).toBe('account-transform-1')
      expect(electroAccount.providerAccountId).toBe('apple-transform-123')

      // Store in DynamoDB
      await Accounts.create(electroAccount).go()

      // Retrieve from DynamoDB
      const result = await Accounts.get({accountId: 'account-transform-1'}).go()

      // Transform back to Better Auth format
      const roundTripped = transformAccountToAuth(result.data!)

      // Verify round-trip preserves data and field mapping
      expect(roundTripped.id).toBe(betterAuthAccount.id)
      expect(roundTripped.userId).toBe(betterAuthAccount.userId)
      expect(roundTripped.providerId).toBe(betterAuthAccount.providerId)
      expect(roundTripped.accountId).toBe('apple-transform-123') // Mapped back correctly
      expect(roundTripped.accessToken).toBe(betterAuthAccount.accessToken)
      expect(roundTripped.createdAt).toBeInstanceOf(Date)
      expect(roundTripped.updatedAt).toBeInstanceOf(Date)
    })

    it('should handle name splitting edge cases', () => {
      expect(splitFullName('John Doe')).toEqual({firstName: 'John', lastName: 'Doe'})
      expect(splitFullName('John')).toEqual({firstName: 'John', lastName: ''})
      expect(splitFullName('')).toEqual({firstName: '', lastName: ''})
      expect(splitFullName('John Doe Smith')).toEqual({firstName: 'John', lastName: 'Doe Smith'})
      expect(splitFullName('Jean-Claude Van Damme')).toEqual({firstName: 'Jean-Claude', lastName: 'Van Damme'})
    })

    it('should handle null to undefined conversion for optional fields', async () => {
      // Better Auth may provide null for optional fields
      const betterAuthSession = {
        id: 'session-null-test',
        userId: 'user-null-test',
        expiresAt: new Date(Date.now() + 86400000),
        token: 'null-test-token',
        ipAddress: null as string | null, // Better Auth uses null
        userAgent: null as string | null
      }

      // Transform to ElectroDB format
      const electroSession = transformSessionFromAuth(betterAuthSession)

      // Verify null converted to undefined (ElectroDB compatibility)
      expect(electroSession.ipAddress).toBeUndefined()
      expect(electroSession.userAgent).toBeUndefined()

      // Store in DynamoDB
      await Sessions.create(electroSession).go()

      // Retrieve and verify undefined fields are handled
      const result = await Sessions.get({sessionId: 'session-null-test'}).go()
      expect(result.data).toBeDefined()
      expect(result.data?.ipAddress).toBeUndefined()
      expect(result.data?.userAgent).toBeUndefined()
    })
  })
})
